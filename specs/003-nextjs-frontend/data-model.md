# Data Model: Next.js 16 Frontend

**Feature**: 003-nextjs-frontend
**Date**: 2025-12-12
**Purpose**: Define data structures, schemas, and type contracts for Phase 2 frontend

---

## Overview

The frontend manages two distinct data domains:
1. **Authentication Data**: Managed via Drizzle ORM with Neon PostgreSQL (User, Session, Account tables)
2. **Task Data**: Consumed from FastAPI backend via Server Actions (NEVER queried directly)

**Key Principle**: Frontend owns auth data persistence but delegates task data to backend API.

---

## 1. Authentication Schema (Drizzle ORM)

### Database: Neon PostgreSQL

**Connection**: Serverless PostgreSQL via `@neondatabase/serverless`
**ORM**: Drizzle ORM with Better Auth adapter
**Scope**: Auth tables ONLY (User, Session, Account)

### User Table

```typescript
// db/schema.ts
import { pgTable, text, timestamp, boolean } from "drizzle-orm/pg-core"

export const user = pgTable("user", {
  id: text("id").primaryKey(), // Generated by Better Auth
  name: text("name").notNull(), // For avatar initials (e.g., "John Doe" → "JD")
  email: text("email").notNull().unique(),
  emailVerified: boolean("emailVerified").notNull().default(false),
  image: text("image"), // Optional profile picture URL
  createdAt: timestamp("createdAt").notNull().defaultNow(),
  updatedAt: timestamp("updatedAt").notNull().defaultNow(),
})
```

**Fields**:
- `id`: Unique user identifier (string UUID from Better Auth)
- `name`: Full name (required for avatar initials generation)
- `email`: Unique email address
- `emailVerified`: Email verification status (default: false)
- `image`: Optional profile picture URL
- `createdAt`: Account creation timestamp
- `updatedAt`: Last profile update timestamp

**Constraints**:
- Primary key: `id`
- Unique constraint: `email`

### Session Table

```typescript
export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expiresAt").notNull(),
  ipAddress: text("ipAddress"),
  userAgent: text("userAgent"),
  userId: text("userId")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
})
```

**Fields**:
- `id`: Session identifier
- `expiresAt`: Session expiration timestamp
- `ipAddress`: User's IP address (for security tracking)
- `userAgent`: Browser user agent string
- `userId`: Foreign key to user table

**Constraints**:
- Primary key: `id`
- Foreign key: `userId` → `user.id` (cascade delete)

### Account Table

```typescript
export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("accountId").notNull(), // Provider-specific ID
  providerId: text("providerId").notNull(), // "credential" for email/password
  userId: text("userId")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("accessToken"),
  refreshToken: text("refreshToken"),
  idToken: text("idToken"),
  expiresAt: timestamp("expiresAt"),
  password: text("password"), // Hashed password for email/password auth
})
```

**Fields**:
- `id`: Account identifier
- `accountId`: Provider-specific account ID
- `providerId`: Authentication provider ("credential" for email/password)
- `userId`: Foreign key to user table
- `accessToken`: OAuth access token (not used in Phase 2)
- `refreshToken`: OAuth refresh token (not used in Phase 2)
- `idToken`: OpenID Connect ID token (not used in Phase 2)
- `expiresAt`: Token expiration timestamp
- `password`: Bcrypt-hashed password for email/password auth

**Constraints**:
- Primary key: `id`
- Foreign key: `userId` → `user.id` (cascade delete)

---

## 2. Task Data Types (API Contract)

**Source**: FastAPI backend via Server Actions
**Storage**: NOT stored in frontend database
**Access**: HTTP GET/POST/PUT/DELETE via `/api/{user_id}/tasks`

### Task Entity

```typescript
// types/task.ts
export interface Task {
  id: string                    // UUID from backend
  user_id: string              // Owner's user ID
  title: string                // 1-200 characters
  description: string | null   // 0-1000 characters, optional
  completed: boolean           // Completion status
  created_at: string           // ISO 8601 timestamp
  updated_at: string           // ISO 8601 timestamp
}
```

**Field Constraints**:
- `id`: UUID string, generated by backend
- `user_id`: Must match authenticated user's ID
- `title`: Required, 1-200 characters
- `description`: Optional, max 1000 characters
- `completed`: Boolean, default false
- `created_at`: ISO 8601 timestamp from backend
- `updated_at`: ISO 8601 timestamp from backend

### Task Create Payload

```typescript
export interface CreateTaskInput {
  title: string       // Required, 1-200 characters
  description?: string // Optional, max 1000 characters
}
```

### Task Update Payload

```typescript
export interface UpdateTaskInput {
  title?: string       // Optional, 1-200 characters
  description?: string // Optional, max 1000 characters
  completed?: boolean  // Optional
}
```

### Task Filter Types

```typescript
export type TaskFilter = "all" | "pending" | "completed"

export interface TaskQueryParams {
  status?: "pending" | "completed" // Omit for "all"
}
```

---

## 3. Session State Management

### Client-Side Session

```typescript
// types/auth.ts
export interface UserSession {
  user: {
    id: string
    name: string
    email: string
    image?: string
  }
  session: {
    id: string
    expiresAt: number // Unix timestamp
  }
}
```

**Access Pattern**:
```typescript
// Server Components
import { auth } from "@/lib/auth"

const session = await auth.api.getSession({
  headers: await headers()
})

// Client Components
import { useSession } from "@/lib/auth-client"

const { data: session } = useSession()
```

### JWT Token Structure

```typescript
export interface JWTPayload {
  sub: string      // User ID
  email: string    // User email
  iat: number      // Issued at (Unix timestamp)
  exp: number      // Expiration (Unix timestamp)
}
```

**Token Lifecycle**:
- **Algorithm**: HS256 (shared secret)
- **Secret**: `BETTER_AUTH_SECRET` (shared with backend)
- **Expiration**: 7 days from issuance
- **Refresh**: Automatic after 24 hours of activity
- **Storage**: HTTP-only cookie (`better-auth.session_token`)

---

## 4. API Response Types

### Success Response

```typescript
// types/api.ts
export interface ApiSuccessResponse<T> {
  data: T
  message?: string
}
```

### Error Response

```typescript
export interface ApiErrorResponse {
  error: {
    message: string
    code?: string
    details?: Record<string, string[]> // Validation errors
  }
}
```

### Paginated Response (Future)

```typescript
export interface PaginatedResponse<T> {
  data: T[]
  pagination: {
    total: number
    page: number
    pageSize: number
    totalPages: number
  }
}
```

---

## 5. Validation Schemas (Zod)

### Task Validation

```typescript
// lib/validation.ts
import { z } from "zod"

export const createTaskSchema = z.object({
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be 200 characters or less"),
  description: z.string()
    .max(1000, "Description must be 1000 characters or less")
    .optional()
    .nullable(),
})

export const updateTaskSchema = z.object({
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be 200 characters or less")
    .optional(),
  description: z.string()
    .max(1000, "Description must be 1000 characters or less")
    .optional()
    .nullable(),
  completed: z.boolean().optional(),
})
```

### Auth Validation

```typescript
export const signUpSchema = z.object({
  name: z.string()
    .min(1, "Name is required")
    .max(100, "Name must be 100 characters or less"),
  email: z.string()
    .email("Invalid email address"),
  password: z.string()
    .min(8, "Password must be at least 8 characters")
    .max(100, "Password must be 100 characters or less"),
})

export const signInSchema = z.object({
  email: z.string()
    .email("Invalid email address"),
  password: z.string()
    .min(1, "Password is required"),
})
```

---

## 6. Data Flow Diagrams

### Authentication Flow

```
1. User submits sign-up/sign-in form (Client Component)
   ↓
2. Better Auth validates credentials
   ↓
3. User/Account/Session records created in Neon DB (via Drizzle)
   ↓
4. JWT token generated with HS256 (shared secret)
   ↓
5. Token stored in HTTP-only cookie
   ↓
6. User redirected to /dashboard
```

### Task CRUD Flow

```
1. User action in dashboard (create/update/delete task)
   ↓
2. Client Component calls Server Action (actions/tasks.ts)
   ↓
3. Server Action validates session (Better Auth)
   ↓
4. Server Action fetches user ID from session
   ↓
5. Server Action makes HTTP request to FastAPI: /api/{user_id}/tasks
   ↓
6. Backend returns task data
   ↓
7. Server Action revalidates path (Next.js cache)
   ↓
8. UI updates (optimistic UI with rollback on error)
```

### Session Validation Flow

```
1. Request to /dashboard
   ↓
2. proxy.ts intercepts request (runs before render)
   ↓
3. Reads session token from cookie
   ↓
4. Validates JWT signature with BETTER_AUTH_SECRET
   ↓
5. Checks expiration timestamp
   ↓
6. Valid? → Allow request to continue
   Invalid/Expired? → Redirect to /sign-in
```

---

## 7. Type Inference from Drizzle

### Generated Types

```typescript
// Automatically inferred from schema
import { InferSelectModel, InferInsertModel } from "drizzle-orm"
import { user, session, account } from "@/db/schema"

export type User = InferSelectModel<typeof user>
export type Session = InferSelectModel<typeof session>
export type Account = InferSelectModel<typeof account>

export type NewUser = InferInsertModel<typeof user>
export type NewSession = InferInsertModel<typeof session>
export type NewAccount = InferInsertModel<typeof account>
```

**Usage**:
```typescript
import type { User } from "@/types/auth"

function getUserInitials(user: User): string {
  const names = user.name.split(" ")
  return names.map(n => n[0]).join("").toUpperCase().slice(0, 2)
}
```

---

## 8. Migration Strategy

### Initial Setup

1. **Install Dependencies**:
   ```bash
   npm install drizzle-orm @neondatabase/serverless
   npm install -D drizzle-kit
   ```

2. **Configure Drizzle**:
   ```typescript
   // drizzle.config.ts
   import { defineConfig } from "drizzle-kit"

   export default defineConfig({
     schema: "./db/schema.ts",
     out: "./db/migrations",
     dialect: "postgresql",
     dbCredentials: {
       url: process.env.DATABASE_URL!,
     },
   })
   ```

3. **Generate Migration**:
   ```bash
   npx drizzle-kit generate
   ```

4. **Run Migration**:
   ```bash
   npx drizzle-kit migrate
   ```

### Schema Evolution

- **Add fields**: Use `.addColumn()` with default values
- **Remove fields**: Use `.dropColumn()` (ensure no dependencies)
- **Rename fields**: Use `.renameColumn()`
- **Better Auth updates**: Lock version, test migrations locally first

---

## 9. Data Ownership Boundaries

| Data Type | Owner | Storage | Access Method |
|-----------|-------|---------|---------------|
| User profile | Frontend | Neon PostgreSQL | Drizzle ORM |
| Sessions | Frontend | Neon PostgreSQL | Drizzle ORM |
| Accounts | Frontend | Neon PostgreSQL | Drizzle ORM |
| Tasks | Backend | Backend database | Server Actions → FastAPI API |
| JWT tokens | Shared | HTTP-only cookie | Better Auth (HS256 shared secret) |

**Enforcement**:
- ✅ Frontend CAN query `user`, `session`, `account` tables
- ❌ Frontend CANNOT query task table (doesn't exist in frontend DB)
- ✅ Frontend MUST use Server Actions to communicate with backend for tasks
- ✅ All task API calls MUST include authenticated user's ID in URL path

---

## References

- [Drizzle ORM Schema](https://orm.drizzle.team/docs/sql-schema-declaration)
- [Better Auth Tables](https://www.better-auth.com/docs/concepts/database)
- [Neon Serverless Driver](https://neon.tech/docs/serverless/serverless-driver)
- [Zod Validation](https://zod.dev/)
