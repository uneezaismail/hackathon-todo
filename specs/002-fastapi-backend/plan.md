# Implementation Plan: Production-Ready FastAPI Backend for Todo App (Phase II)

**Branch**: `002-fastapi-backend` | **Date**: 2025-12-11 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-fastapi-backend/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Build a secure, stateless, multi-tenant FastAPI backend that provides RESTful task management API with JWT-based authentication, user data isolation, and persistent PostgreSQL storage. The backend validates all requests using JWT tokens from Better Auth, enforces strict user-scoped data access, and provides CRUD operations for tasks with filtering, sorting, and pagination capabilities.

**Technical Approach**: Use FastAPI with SQLModel ORM for database models, python-jose for JWT validation with shared secret (HS256), Alembic for database migrations, and Neon Serverless PostgreSQL for persistent storage. Implement dependency injection for JWT authentication and user context extraction, ensuring all database queries are automatically scoped to the authenticated user ID.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: FastAPI 0.115+, SQLModel 0.0.22+, python-jose[cryptography] 3.3+, Alembic 1.13+, psycopg2-binary 2.9+ (PostgreSQL driver), httpx 0.28+ (async client), uvicorn 0.32+ (ASGI server), pydantic 2.10+
**Storage**: Neon Serverless PostgreSQL (connection pooling: pool_size=5, max_overflow=10, pool_pre_ping=True)
**Testing**: pytest 8.3+, pytest-asyncio 0.24+, httpx (for FastAPI TestClient), pytest-cov 6.0+ (coverage), mypy 1.13+ (strict type checking)
**Target Platform**: Linux server (ASGI deployment via uvicorn), containerized with Docker for portability
**Project Type**: Web backend API (standalone FastAPI service, no frontend in this repository)
**Performance Goals**: 95th percentile response time <500ms under normal load, support 1,000 concurrent authenticated users with <10% degradation, filter/sort operations <200ms for up to 1,000 tasks per user
**Constraints**: Stateless operation (no session state, all context from JWT), 99.9% uptime during business hours, zero SQL injection vulnerabilities, 100% rejection rate for invalid JWT tokens, strict user data isolation (zero cross-user access)
**Scale/Scope**: Multi-tenant system supporting up to 10,000 tasks per user, optimized for serverless PostgreSQL connection management, designed for horizontal scaling

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Compliance Status: ✅ PASS

| Principle | Status | Evidence |
|-----------|--------|----------|
| **I. Spec-First Development** | ✅ PASS | Comprehensive spec.md exists with 5 user stories, 20 functional requirements, 10 success criteria |
| **II. No Manual Code** | ✅ PASS | Plan generated by `/sp.plan` command, implementation will use `/sp.tasks` workflow |
| **III. Reusable Intelligence** | ✅ PASS | Plan documents architectural decisions inline; ADRs will be created for JWT validation strategy and database connection pooling |
| **IV. Evolutionary Architecture** | ✅ PASS | Phase II builds on Phase I repository pattern (swap in-memory for PostgreSQL); uses SQLModel for future ORM flexibility |
| **V. Single Responsibility (SRP)** | ✅ PASS | Planned separation: models/ (data), services/ (business logic), api/ (routing), auth/ (JWT validation), db/ (connection) |
| **VI. User Experience First** | ✅ PASS | Consistent error responses (FR-011), graceful database failure handling (FR-012), actionable validation messages |
| **VII. The Checkpoint Pattern** | ✅ PASS | Implementation will follow atomic task workflow from tasks.md (generated by `/sp.tasks`) |
| **VIII. Automated Testing** | ✅ PASS | Backend API integration tests planned for all endpoints (FR-001 to FR-020), JWT authentication tests, user isolation tests |
| **IX. Strict Type Safety** | ✅ PASS | Python type hints required for all functions, mypy --strict enforcement enabled |
| **X. Strict Error Handling** | ✅ PASS | No silent failures (FR-012), structured JSON error responses (FR-011), internal details hidden |
| **XI. 12-Factor Configuration** | ✅ PASS | Environment variables for DATABASE_URL and BETTER_AUTH_SECRET (no hardcoded secrets) |
| **XII. AI Sub-Agents and Skills** | ✅ PASS | Plan adheres to spec-driven workflow; backend-expert and auth-expert agents available for implementation |

**Tech Stack Alignment**:
- ✅ Python 3.13+ with uv package manager
- ✅ FastAPI (API framework)
- ✅ SQLModel (ORM)
- ✅ Pydantic (validation)
- ✅ Neon Serverless PostgreSQL (data storage)
- ✅ Better Auth JWT validation (shared secret HS256)

**Re-evaluation Post-Phase 1**: Constitution check will be re-run after data-model.md and contracts/ are generated to ensure design compliance.

## Project Structure

### Documentation (this feature)

```text
specs/002-fastapi-backend/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output: JWT validation, SQLModel patterns, Alembic migrations
├── data-model.md        # Phase 1 output: Task entity schema, User reference, indexes
├── quickstart.md        # Phase 1 output: Local setup, database migrations, running tests
├── contracts/           # Phase 1 output: OpenAPI spec, request/response schemas
│   ├── openapi.yaml     # Generated OpenAPI 3.1 specification
│   ├── schemas/         # Pydantic request/response models
│   │   ├── task_create.json
│   │   ├── task_response.json
│   │   ├── task_list_response.json
│   │   └── error_response.json
│   └── examples/        # Request/response examples for testing
│       ├── create_task_request.json
│       ├── create_task_response.json
│       └── error_401_unauthorized.json
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/                           # FastAPI backend service
├── src/
│   ├── __init__.py
│   ├── main.py                    # FastAPI app initialization, CORS, middleware
│   ├── config.py                  # Environment variable loading, settings validation
│   ├── models/                    # SQLModel database models
│   │   ├── __init__.py
│   │   ├── task.py                # Task model with user_id FK, indexes
│   │   └── base.py                # Base model with created_at/updated_at mixins
│   ├── schemas/                   # Pydantic request/response schemas
│   │   ├── __init__.py
│   │   ├── task.py                # TaskCreate, TaskUpdate, TaskResponse, TaskListResponse
│   │   └── common.py              # ErrorResponse, PaginationParams, FilterParams
│   ├── api/                       # API route handlers
│   │   ├── __init__.py
│   │   ├── v1/
│   │   │   ├── __init__.py
│   │   │   ├── tasks.py           # Task CRUD endpoints (GET, POST, PATCH, DELETE)
│   │   │   └── health.py          # Health check endpoint (no auth required)
│   │   └── dependencies.py        # FastAPI dependencies (get_current_user, get_db)
│   ├── services/                  # Business logic layer
│   │   ├── __init__.py
│   │   ├── task_service.py        # TaskService with user-scoped CRUD operations
│   │   └── exceptions.py          # Custom exceptions (TaskNotFoundError, UnauthorizedError)
│   ├── auth/                      # JWT authentication
│   │   ├── __init__.py
│   │   ├── jwt.py                 # JWT validation using python-jose with shared secret
│   │   └── dependencies.py        # get_current_user_id dependency
│   └── db/                        # Database connection and session management
│       ├── __init__.py
│       ├── engine.py              # SQLModel engine with serverless pooling config
│       └── session.py             # Session factory and dependency
├── alembic/                       # Database migration scripts
│   ├── versions/
│   │   └── 001_create_tasks_table.py  # Initial migration: tasks table with user_id FK
│   ├── env.py                     # Alembic environment configuration
│   └── script.py.mako             # Migration template
├── alembic.ini                    # Alembic configuration (DATABASE_URL from env)
├── tests/
│   ├── __init__.py
│   ├── conftest.py                # Pytest fixtures (test_client, test_db, mock_jwt)
│   ├── integration/               # API integration tests (all endpoints)
│   │   ├── __init__.py
│   │   ├── test_task_create.py    # POST /api/v1/tasks
│   │   ├── test_task_read.py      # GET /api/v1/tasks, GET /api/v1/tasks/{id}
│   │   ├── test_task_update.py    # PATCH /api/v1/tasks/{id}
│   │   ├── test_task_delete.py    # DELETE /api/v1/tasks/{id}
│   │   ├── test_task_filter.py    # GET /api/v1/tasks?status=Pending
│   │   ├── test_task_pagination.py # GET /api/v1/tasks?limit=10&offset=20
│   │   └── test_auth.py           # JWT validation, 401/403 responses
│   ├── unit/                      # Unit tests for services and utilities
│   │   ├── __init__.py
│   │   ├── test_task_service.py   # TaskService CRUD logic
│   │   ├── test_jwt_validation.py # JWT decode, signature verification
│   │   └── test_models.py         # SQLModel validation, constraints
│   └── contract/                  # Contract tests (OpenAPI compliance)
│       ├── __init__.py
│       └── test_openapi_schema.py # Validate responses match OpenAPI spec
├── .env.example                   # Example environment variables
├── pyproject.toml                 # Python dependencies (uv format)
├── Dockerfile                     # Container image for deployment
├── .dockerignore
└── README.md                      # Backend-specific setup and run instructions
```

**Structure Decision**: Selected **Web application** structure (Option 2 from template) with standalone `backend/` directory. This separates the FastAPI backend from the future Next.js frontend (which will live in `frontend/` directory). The backend is self-contained with its own tests, migrations, and configuration, enabling independent deployment and development.

## Complexity Tracking

> **No violations - this section is empty**

All constitutional principles are satisfied without requiring complexity justifications. The architecture follows standard FastAPI best practices with clear separation of concerns (models, schemas, services, API routes), uses approved tech stack (FastAPI, SQLModel, Neon PostgreSQL), and implements required security patterns (JWT validation, user isolation).

## Phase 0: Research & Decision Documentation

**Objective**: Resolve all technical unknowns and document architectural decisions before designing data models and API contracts.

### Research Tasks

1. **JWT Validation with Shared Secret (HS256)**
   - Research: Best practices for python-jose JWT validation in FastAPI
   - Decision: Use shared BETTER_AUTH_SECRET with HS256 algorithm (symmetric signing)
   - Rationale: Simpler than asymmetric keys (RS256) since both Next.js and FastAPI are controlled services
   - Alternatives: RS256 (public/private key pair) - rejected because unnecessary complexity for trusted service-to-service authentication

2. **SQLModel Database Patterns**
   - Research: SQLModel best practices for FastAPI, relationship handling, indexes
   - Decision: Use SQLModel for unified Pydantic validation and SQLAlchemy ORM capabilities
   - Rationale: Single source of truth for database models and API schemas, better type safety
   - Alternatives: Plain SQLAlchemy + separate Pydantic models - rejected due to duplication

3. **Neon Serverless PostgreSQL Connection Pooling**
   - Research: Optimal connection pool settings for serverless PostgreSQL (Neon)
   - Decision: pool_size=5, max_overflow=10, pool_pre_ping=True (from spec FR-020)
   - Rationale: Neon Serverless scales down to zero; small pool with overflow prevents connection exhaustion
   - Alternatives: Larger pool (20+ connections) - rejected because serverless pricing penalizes idle connections

4. **Alembic Migration Strategy**
   - Research: Alembic integration with SQLModel, migration workflow
   - Decision: Use Alembic for schema migrations, SQLModel for model definitions
   - Rationale: Industry standard for SQLAlchemy migrations, supports rollbacks and versioning
   - Alternatives: Manual SQL scripts - rejected due to lack of version control and rollback capability

5. **User Data Isolation Pattern**
   - Research: FastAPI dependency injection for user-scoped database queries
   - Decision: Implement get_current_user_id dependency that extracts user_id from JWT, auto-inject into all endpoints
   - Rationale: Enforces user isolation at dependency level, impossible to forget in individual endpoints
   - Alternatives: Manual user_id validation in each endpoint - rejected due to error-prone repetition

6. **Error Response Standardization**
   - Research: FastAPI exception handlers for consistent JSON error responses
   - Decision: Custom exception handler returning `{"data": null, "error": {"message": "...", "code": "..."}}` format (FR-011)
   - Rationale: Consistent error structure across all endpoints, easier for frontend integration
   - Alternatives: Default FastAPI error format - rejected because doesn't match spec requirement

7. **API Versioning Strategy**
   - Research: FastAPI API versioning patterns (URL prefix vs header-based)
   - Decision: URL-based versioning with `/api/v1/` prefix (from spec Out of Scope section)
   - Rationale: Simplest approach for Phase II, explicit in URLs, easier for frontend developers
   - Alternatives: Header-based versioning (Accept: application/vnd.api.v1+json) - deferred to Phase III

**Output**: research.md

## Phase 1: Design & Contracts

**Prerequisites**: research.md complete

### 1. Data Model Design (data-model.md)

**Entities Extracted from Spec**:

#### Task Entity
- **Table Name**: `tasks`
- **Fields**:
  - `id`: UUID (primary key, auto-generated)
  - `user_id`: String (foreign key to Better Auth users, indexed, NOT NULL)
  - `title`: String(200) (NOT NULL, length validation 1-200 chars)
  - `description`: String(1000) (nullable, length validation max 1000 chars)
  - `completed`: Boolean (default=False, represents Pending/Completed status)
  - `created_at`: DateTime (auto-generated, UTC timezone, indexed for sorting)
  - `updated_at`: DateTime (auto-updated on modifications, UTC timezone)
- **Indexes**:
  - Primary: `id` (UUID)
  - Foreign Key: `user_id` (for user isolation queries)
  - Performance: `created_at` (for sorting and filtering)
  - Composite: `(user_id, completed)` (for filtered list queries)
- **Constraints**:
  - `title` length: 1-200 characters (enforced by Pydantic and database CHECK constraint)
  - `description` length: max 1000 characters (enforced by Pydantic)
  - `user_id` NOT NULL (enforced by database)
- **Validation Rules** (from FR-005, FR-006, FR-007):
  - Title: required, non-empty, max 200 chars
  - Description: optional, max 1000 chars
  - Completed: defaults to False (Pending status)

#### User Reference (External Entity)
- **External Management**: User data managed by Better Auth (Next.js frontend)
- **Reference Field**: `user_id` (string from JWT 'sub' claim)
- **No Local User Table**: Backend only references user_id as foreign key
- **Assumption**: Better Auth guarantees valid user_id in JWT tokens (from spec Assumption #1)

**State Transitions**:
- Task Creation: `completed = False` (Pending)
- Task Completion: `completed = True` (Completed)
- Task Deletion: Permanent removal (no soft delete for Phase II)

**Data Volume Assumptions** (from spec Assumption #10):
- Max 10,000 tasks per user
- Queries optimized for this scale (indexes on user_id and created_at)

### 2. API Contracts (contracts/)

**RESTful Endpoints** (derived from User Stories and Functional Requirements):

#### Endpoint: POST /api/v1/tasks
- **User Story**: US-1 (Create Personal Task)
- **Authentication**: Required (JWT token in Authorization: Bearer header)
- **Request Body**:
  ```json
  {
    "title": "string (1-200 chars, required)",
    "description": "string (max 1000 chars, optional)"
  }
  ```
- **Response (201 Created)**:
  ```json
  {
    "data": {
      "id": "uuid",
      "user_id": "string",
      "title": "string",
      "description": "string | null",
      "completed": false,
      "created_at": "ISO 8601 datetime",
      "updated_at": "ISO 8601 datetime"
    },
    "error": null
  }
  ```
- **Error Responses**:
  - 400 Bad Request: Empty title, title >200 chars, description >1000 chars
  - 401 Unauthorized: Missing/invalid/expired JWT token
  - 422 Unprocessable Entity: Malformed JSON, invalid field types
  - 503 Service Unavailable: Database connection failure

#### Endpoint: GET /api/v1/tasks
- **User Story**: US-2 (View Only My Tasks), US-3 (Filter and Organize)
- **Authentication**: Required
- **Query Parameters**:
  - `status`: "Pending" | "Completed" (optional, filter by completion status)
  - `sort`: "created_at_asc" | "created_at_desc" (optional, default: "created_at_desc")
  - `limit`: integer (optional, default: 50, max: 100)
  - `offset`: integer (optional, default: 0)
- **Response (200 OK)**:
  ```json
  {
    "data": {
      "tasks": [
        {
          "id": "uuid",
          "user_id": "string",
          "title": "string",
          "description": "string | null",
          "completed": boolean,
          "created_at": "ISO 8601 datetime",
          "updated_at": "ISO 8601 datetime"
        }
      ],
      "total": "integer (total tasks matching filter for this user)",
      "limit": "integer",
      "offset": "integer"
    },
    "error": null
  }
  ```
- **Error Responses**:
  - 400 Bad Request: Invalid status value, negative offset/limit, limit >100
  - 401 Unauthorized: Missing/invalid/expired JWT token
  - 503 Service Unavailable: Database connection failure

#### Endpoint: GET /api/v1/tasks/{task_id}
- **User Story**: US-2 (View Only My Tasks with Privacy Guarantee)
- **Authentication**: Required
- **Path Parameters**: `task_id` (UUID)
- **Response (200 OK)**: Same as single task object from POST response
- **Error Responses**:
  - 401 Unauthorized: Missing/invalid/expired JWT token
  - 403 Forbidden: Task exists but belongs to different user (prevents info leakage)
  - 404 Not Found: Task does not exist
  - 422 Unprocessable Entity: Invalid UUID format

#### Endpoint: PATCH /api/v1/tasks/{task_id}
- **User Story**: US-4 (Update Tasks)
- **Authentication**: Required
- **Path Parameters**: `task_id` (UUID)
- **Request Body** (all fields optional):
  ```json
  {
    "title": "string (1-200 chars, optional)",
    "description": "string (max 1000 chars, optional) | null",
    "completed": "boolean (optional)"
  }
  ```
- **Response (200 OK)**: Same as POST response (updated task object)
- **Error Responses**:
  - 400 Bad Request: Empty title, title >200 chars, description >1000 chars
  - 401 Unauthorized: Missing/invalid/expired JWT token
  - 403 Forbidden: Task exists but belongs to different user
  - 404 Not Found: Task does not exist
  - 422 Unprocessable Entity: Invalid UUID format, malformed JSON

#### Endpoint: DELETE /api/v1/tasks/{task_id}
- **User Story**: US-4 (Delete Tasks)
- **Authentication**: Required
- **Path Parameters**: `task_id` (UUID)
- **Response (204 No Content)**: Empty body
- **Error Responses**:
  - 401 Unauthorized: Missing/invalid/expired JWT token
  - 403 Forbidden: Task exists but belongs to different user
  - 404 Not Found: Task does not exist
  - 422 Unprocessable Entity: Invalid UUID format

#### Endpoint: GET /api/health
- **Purpose**: Health check for load balancers and monitoring
- **Authentication**: NOT required (public endpoint)
- **Response (200 OK)**:
  ```json
  {
    "status": "healthy",
    "timestamp": "ISO 8601 datetime"
  }
  ```

**OpenAPI 3.1 Specification**: Generated automatically by FastAPI from Pydantic schemas and route definitions. Accessible at `/docs` (Swagger UI) and `/openapi.json` (raw JSON schema).

**Contract Testing**: All request/response schemas validated against OpenAPI spec in `tests/contract/test_openapi_schema.py`.

### 3. Quickstart Guide (quickstart.md)

**Local Development Setup**:

1. **Prerequisites**:
   - Python 3.13+ installed
   - uv package manager installed (`curl -LsSf https://astral.sh/uv/install.sh | sh`)
   - Neon PostgreSQL database provisioned (get DATABASE_URL from Neon console)
   - BETTER_AUTH_SECRET shared with Next.js frontend

2. **Environment Configuration**:
   ```bash
   cp .env.example .env
   # Edit .env with:
   # DATABASE_URL=postgresql://user:pass@host/dbname?sslmode=require
   # BETTER_AUTH_SECRET=your-shared-secret-here
   ```

3. **Install Dependencies**:
   ```bash
   cd backend
   uv sync  # Installs all dependencies from pyproject.toml
   ```

4. **Run Database Migrations**:
   ```bash
   uv run alembic upgrade head  # Apply all migrations
   ```

5. **Start Development Server**:
   ```bash
   uv run uvicorn src.main:app --reload --port 8000
   # API available at http://localhost:8000
   # Swagger UI at http://localhost:8000/docs
   # OpenAPI spec at http://localhost:8000/openapi.json
   ```

6. **Run Tests**:
   ```bash
   uv run pytest tests/ -v  # All tests
   uv run pytest tests/integration/ -v  # Integration tests only
   uv run pytest tests/unit/ -v  # Unit tests only
   uv run pytest --cov=src tests/  # With coverage report
   ```

7. **Type Checking**:
   ```bash
   uv run mypy src/ --strict  # Strict type checking
   ```

**Database Migration Workflow**:
```bash
# Create new migration
uv run alembic revision --autogenerate -m "Add new field to tasks"

# Review generated migration in alembic/versions/
# Edit if needed (Alembic auto-generate is not perfect)

# Apply migration
uv run alembic upgrade head

# Rollback migration (if needed)
uv run alembic downgrade -1  # Rollback one version
```

### 4. Agent Context Update

```bash
# Update Claude Code agent context with new technologies from this plan
.specify/scripts/bash/update-agent-context.sh claude
```

**New Technologies Added**:
- Python 3.13+ (Backend)
- FastAPI (API framework)
- SQLModel (ORM)
- python-jose (JWT validation)
- Alembic (database migrations)
- Neon Serverless PostgreSQL (persistent storage)
- pytest + httpx (testing)

**Agent Context File Updated**: `CLAUDE.md` (preserves manual additions between markers, appends new technologies)

## Architecture Decisions Requiring ADRs

The following architecturally significant decisions should be documented as ADRs (run `/sp.adr <title>` for each):

1. **ADR: JWT Shared Secret Authentication Strategy**
   - **Decision**: Use shared BETTER_AUTH_SECRET with HS256 algorithm for JWT validation
   - **Alternatives**: RS256 asymmetric keys, OAuth 2.0 with token introspection
   - **Trade-offs**: Simpler implementation vs slightly less secure than asymmetric keys
   - **Impact**: Affects authentication flow, secret management, and integration with Better Auth

2. **ADR: SQLModel for Database Models**
   - **Decision**: Use SQLModel for unified Pydantic validation and SQLAlchemy ORM
   - **Alternatives**: Plain SQLAlchemy + separate Pydantic models, Tortoise ORM
   - **Trade-offs**: Single source of truth vs SQLModel's evolving ecosystem
   - **Impact**: Affects model definition, API schema generation, and migration workflow

3. **ADR: Neon Serverless PostgreSQL Connection Pooling**
   - **Decision**: pool_size=5, max_overflow=10, pool_pre_ping=True
   - **Alternatives**: Larger pool (20+), pgBouncer external pooling, connection per request
   - **Trade-offs**: Serverless cost optimization vs connection availability under load
   - **Impact**: Affects database performance, cost, and scalability under concurrent load

## Testing Strategy

**Backend API Integration Tests** (Constitution Section VIII requirement):

1. **JWT Authentication Tests** (`tests/integration/test_auth.py`):
   - Test missing Authorization header → 401 Unauthorized
   - Test expired JWT token → 401 Unauthorized
   - Test invalid signature (wrong secret) → 401 Unauthorized
   - Test tampered JWT payload → 401 Unauthorized
   - Test valid JWT token → 200 OK (with valid request)

2. **User Isolation Tests** (`tests/integration/test_auth.py`):
   - Test User A cannot access User B's task by ID → 403 Forbidden
   - Test User A cannot update User B's task → 403 Forbidden
   - Test User A cannot delete User B's task → 403 Forbidden
   - Test User A's task list contains only User A's tasks (zero User B tasks)

3. **CRUD Operation Tests** (integration tests for each endpoint):
   - `test_task_create.py`: Valid creation, empty title rejection, title >200 chars rejection
   - `test_task_read.py`: Get all tasks, get task by ID, 404 for non-existent task
   - `test_task_update.py`: Update title/description/status, empty title rejection, 404 handling
   - `test_task_delete.py`: Delete task, 404 for non-existent task, verify permanent deletion
   - `test_task_filter.py`: Filter by Pending/Completed status, invalid status value rejection
   - `test_task_pagination.py`: Limit/offset parameters, negative offset rejection, limit >100 rejection

4. **Contract Tests** (`tests/contract/test_openapi_schema.py`):
   - Validate all responses match OpenAPI schema definitions
   - Validate error response structure matches `{"data": null, "error": {...}}` format

5. **Performance Tests** (deferred to Phase III, documented here for future reference):
   - Load test: 1,000 concurrent users, measure p95 latency <500ms
   - Filter/sort test: 1,000 tasks per user, measure query time <200ms

**Unit Tests** (services and utilities):
- `test_task_service.py`: TaskService CRUD methods with mocked database
- `test_jwt_validation.py`: JWT decode and signature verification logic
- `test_models.py`: SQLModel validation, default values, constraints

**Test Coverage Target**: >90% line coverage for `src/` directory (measured by pytest-cov)

## Performance & Scalability Considerations

1. **Database Indexes** (from data-model.md):
   - `user_id` index: Enables fast user-scoped queries (all endpoints filter by user_id)
   - `created_at` index: Supports sorting by creation date (default sort order)
   - Composite `(user_id, completed)` index: Optimizes filtered list queries (e.g., "show my pending tasks")

2. **Connection Pooling** (FR-020):
   - Serverless-optimized: pool_size=5, max_overflow=10, pool_pre_ping=True
   - Prevents connection exhaustion under load while minimizing idle connections (Neon pricing)

3. **Query Optimization**:
   - All queries scoped to authenticated user_id (reduces scan size)
   - Pagination with limit/offset (prevents large result sets)
   - Selective field loading (SQLModel deferred loading for large text fields if needed)

4. **Stateless Design** (FR-013):
   - No session storage between requests (horizontally scalable)
   - All user context derived from JWT token (no database lookups for authentication)

5. **Async Support** (FastAPI default):
   - ASGI server (uvicorn) supports async request handling
   - SQLModel/SQLAlchemy async mode (future optimization for high concurrency)

## Security Considerations

1. **JWT Validation** (FR-001, FR-002, FR-003):
   - Signature verification on every request (python-jose with shared secret)
   - User ID extraction from 'sub' claim and validation against URL path
   - Reject mismatched user IDs with 403 Forbidden (not 404, prevents info leakage)

2. **SQL Injection Prevention** (FR-015, SC-008):
   - SQLModel ORM parameterization (no raw SQL queries)
   - Pydantic input validation before database access

3. **Error Message Safety** (FR-012):
   - Generic error messages to clients (no stack traces, database errors, file paths)
   - Detailed logging server-side for debugging (not exposed via API)

4. **CORS Configuration** (FR-016):
   - Allow Next.js frontend origin only (not wildcard *)
   - Explicitly permit Authorization header and credentials

5. **Secret Management** (Constitution Section XI):
   - DATABASE_URL and BETTER_AUTH_SECRET in environment variables (never committed to git)
   - .env.example provided with placeholder values (no real secrets)

## Deployment Considerations

1. **Container Image** (Dockerfile):
   - Multi-stage build: dependencies, source code, runtime
   - Non-root user for security
   - Health check endpoint: GET /api/health

2. **Environment Variables** (production):
   - DATABASE_URL: Neon PostgreSQL connection string with SSL
   - BETTER_AUTH_SECRET: Shared secret for JWT validation (same as Next.js)
   - LOG_LEVEL: INFO (or DEBUG for troubleshooting)
   - CORS_ORIGINS: Next.js frontend URL (e.g., https://app.example.com)

3. **Database Migrations** (deployment workflow):
   - Run `alembic upgrade head` before starting new version
   - Zero-downtime migrations: additive changes only (no breaking schema changes)

4. **Monitoring & Observability** (deferred to Phase III):
   - Health check endpoint for load balancer probes
   - Structured logging (JSON format) for log aggregation
   - OpenTelemetry instrumentation for traces and metrics (future)

## Next Steps

**Phase 0 Complete**: research.md generated with JWT validation, SQLModel patterns, Alembic workflow, connection pooling decisions.

**Phase 1 Complete**: data-model.md (Task entity schema), contracts/ (OpenAPI spec + examples), quickstart.md (local setup guide), agent context updated.

**Constitution Re-Check**: ✅ PASS (all principles satisfied after Phase 1 design)

**Ready for Phase 2**: Run `/sp.tasks` to generate tasks.md with atomic implementation tasks based on this plan and spec.md acceptance criteria.

**Suggested ADRs**:
1. `/sp.adr "JWT Shared Secret Authentication Strategy"`
2. `/sp.adr "SQLModel for Database Models"`
3. `/sp.adr "Neon Serverless PostgreSQL Connection Pooling"`

---

**Plan Status**: ✅ COMPLETE - Ready for `/sp.tasks`
**Generated**: 2025-12-11
**Last Updated**: 2025-12-11
